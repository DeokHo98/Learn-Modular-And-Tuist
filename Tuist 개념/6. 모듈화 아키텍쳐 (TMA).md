## 모듈화 아키텍쳐 (The Modular Architecture)
```swift
TMA는 애플 OS 앱을 구조화하기 위한 아키텍처적 접근 방식으로, 확장 가능성을 높이고 빌드 및 테스트 주기를 최적하하여 팀내에서 좋은 관행을 보장하는것을 목표로 한다.
이 아키텍쳐의 핵심 아이디어는 독립적인 기능을 구축하고, 명확하고 간결한 API를 통해 서로 연결된 앱을 구축하는 것이다.
이 가이드라인은 이 아키텍처의 원칙을 소개하며, 앱 기능을 다양한 계층으로 식별하고 구성하는데 도움을 준다.
```

## 핵심 원칙
```swift
개발자는 메인앱과 독립적으로 기능을 빠르게 구축 및 테스트하고 시도할 수 있어야하며, SwiftUI 프리뷰, 코드완성 및 디버깅과 같은 Xcode 기능이 신뢰할 수 있게 작동하는 것을 보장해야한다.
```

## 모듈이란 무엇인가
```swift
모듈은 앱의 기능을 나타나며, 다음 다섯가지 타겟의 조합이다.

- 소스
기능 소스코드(swift)와 그 자원(이미지, 폰트, 색상, xib, 스토리보드)을 포함한다.

- 인터페이스
기능의 공개 인터페이스와 모델을 포함하는 보조 타겟이다.

- 테스트 
기능의 단위 및 통합테스트를 포함한다.

- 테스팅
테스트 및 예제 앱에서 사용할수 있는 데스트 데이터를 제공한다.
또한 다른기능에서 사용할수 있는 모듈클래스와 프로토콜의 목업을 제공한다.

- 예제
개발자가 특정 조건하에서 기능을 시도할 수 있는 예제 앱을 포함한다.(다양한 언어, 화면크기, 설정)

- 프로젝트에서 Tuist의 DSL을 통해 강제할수있는 타겟 이름 규칙을 따르는것을 권장한다.

Feature  소스 코드 및 자원
FeatureInterface - 공개 인터페이스 및 모델
FeatureTests 단위 및 통합 테스트
FeatureTesting 테스트 데이터 및 목업
FeatureExample 예제 앱
```

## 모듈울 사용하는 이유
```swift
1. 명확하고 간결한 API

앱의 모든 소스코드가 같은 타겟에 존재하면 코드 내에서 암시적인 종속성을 만들기 쉽고,
잘알려진 스파게티코드에 빠질수 있다.
모든것이 강하게 결합되어 있고 상태가 예측하기 어려울때가 있으며, 새로운 변경사항을 도입하는것이 악몽이 될 수 있다.
독립적인 타겟에서 기능을 정의할때는 공개 API를 기능 구현의 일부로 설계해야한다.
무엇을 공개할지, 기능이 어떻게 사용될지, 무엇이 비공개로 남아야하는지 결정해야한다.
기능의 클라이언트가 기능을 사용하는 방법을 보다 더많이 통제하고 안전한 API 를 설계함으로써
좋은 관행을 시행할 수 있다.

2. 작은 모듈
작은 모듈에서 작업하면 더 집중할 수 있고, 기능을 격리된 환경에서 테스트하고 시도할 수 있다.
또한 보다 선택적인 컴파일로 개발주기가 훨씬 빨라진다.
기능을 작동하기위해 필요한 컴포넌트만 컴파일하기때문에 전체 앱을 컴파일하는것은 작업을 완료할때 마지막 단계에서만 필요하다.

3. 재사용성
프레임워크나 라이브러리를 사용하여 앱간에 코드를 재사용하는것을 권장한다.
기존 모듈을 결합하고 플랫폼별로 UI 레이어를 추가함으로써 쉽게 앱 및 확장프로그램을 구축할 수 있다.
```

## 의존성
```swift
한 모듈이 다른 모듈에 의존할때 그 모듈은 그인터페이스 타겟에 대한 의존성을 선언한다.
이 방법의 이점은 두 가지이다.

1. 모듈의 구현이 다른 모듈의 구현과 결합되지 않도록 한다.
2. 우리 기능의 구현과 직간접적으로 의존하는 모듈의 인터페이스만을 컴파일 하므로 클린 빌드 속도를 빠르게한다.

인터페이스에 의존하는것은 앱이 실행될때 구현 그래프를 빌드하고, 필요한 모듈에 의존성 주입하는것을 요구한다.
TMA는 이 작업 방법에 대해 의견을 제시하지 않지만, 런타임에서 의존성 주입 솔루션이나 패턴을 사용하거나, 빌드 시간의 지연을 초래하지 않는 해결책을 사용할것을 권장한다.
또한 이를 위해 설계되지 않은 플랫폼 api를 사용하지 않도록 한다.
```

## 제품 유형
```swift
모듈을 빌드할 때 라이브러리와 프레임워크 그리고 타겟의 정적 및 동적 링킹중 선택할 수 있다.
Tuist가 없다면 이 결정을 수동으로 구성해야 하므로 조금 더 복잡해진다.
그러나 Tuist Projects 덕분에 이는 더 이상 문제가 되지 않는다.

게빌 중에는 동적 라이브러리나 프레임워크를 사용하고, 번들 액세서를 통해 번들 액세스 로직을 라이브러리나 프레임워크의 성격해서 분리하는것이 좋다.
이는 빠른 컴파일 시간을 보장하고 SwiftUI 미리보기가 신뢰할 수 있도록 한다.
릴리스 빌드에서는 정적 라이브러리나 프레임워크를 사용하여 앱 부팅 속도를 보장할 수 있다.
생성 시간에 제품 유형을 변경하기 위해 동적 구성을 활용 할 수 있다.

# 매니페스트에서 변수의 값을 읽어와서 링킹 유형을 변경하는 코드
TUIST_PRODUCT_TYPE=static-library tuist generate

// 매니페스트 파일이나 헬퍼에서 이 코드를 사용하여 타겟을 인스턴스화할 때 반환된 값을 사용할 수 있다.
func productType() -> Product {
    if case let .string(productType) = Environment.productType {
        return productType == "static-library" ? .staticLibrary : .framework
    } else {
        return .framework
    }
}

```

## 코드
```swift
TMA는 모듈의 코드 아키텍처 및 패턴에 대해 구체적인 의견을 제시하지 않는다.
그러나 몇가지 경험을 바탕으로 팁을 공유한다.

컴파일러를 활용하는 것이 좋다.
그러나 컴파일러를 지나치게 활용하면 비생산적일 수 있고 Xcode 미리보기와 같은 기능이 신뢰할수 없어진다.
우리는 컴파일러를 사용하여 좋은 관행을 강제하고 오류를 초기에 잡는것을 권장하지만.
코드를 더 읽고 유지보수하기 어렵게 만드는정도까지 지나치지는 말아야한다.

Swift 매크로를 더 적게 사용해자.
Swift 매크로는 매우 매우 강력하지만 코드를 읽고 유지 관리하기 어렵게 만들 수 있다.
플랫폼과 언어를 포용하자, 추상화된 복잡한 계층을 만들려고하지 말자.
플랫폼과 언어는 추가적인 추상화 계층 없이도 훌륭한 앱을 만드는데 충분히 강력하다.
좋은 프로그래밍과 디자인 패턴을 참조하여 기능을 구축하는것이 좋다.
```
