## Tuist란?
```swift
Xcode 프로젝트가 커지면서 여러가지 문제로 인해 생산성이 떨어질수 있다.
이 문제는
 
신뢰할수 없는 증분 빌드
- 증분빌드는 프로젝트를 처음부터 끝까지 다시빌드하는 대신 변경된 파일이나 부분만 다시 빌드하는것을 말한다.

Xcode의 전역 캐시를 자주 지우는것, 취약한 프로젝트 설정 등이 포함된다.
빠른 기능 개발을 유지하기 위해 개발팀들은 다양한 전략을 모색한다.
어떤 조직들은 자바스크립트 기반의 동적런타임을(React Native) 사용해 플랫폼을 추상화함으로 컴파일러를 우회하려고도 하지만 플랫폼의 네이티브한 기능들은 접근하기 어렵다.
다른 조직들은 코드베이스를 모듈화하여 작업하기 쉽게만들고 빌드 시간을 개선하려 한다.
그러나 Xcode 프로젝트 형식은 모듈화에 적합하지 않아 이해하기 어려운 암묵적인 설정과 빈번한 충돌을 도래한다.
이는 중요한 개발자 구성원이 떠났을때 발생하는 리스크를 악화시키고, 증분빌드가 개선되더라도 개발자들은 실패시 Xcode의 빌드 캐시 Derived Data를 자주 지울수 있다.
이에 대응하기 위해 일부 팀들은 Xcode의 빌드 시스템을 포기하고 Buck 이나 Bazeld같은 대아늘 채택하기도 하지만 이는 높은 복잡성과 유지보수 부담을 초래한다.
```

## 편리함의 대가
```swift
Xcode의 설계는 작은 프로젝트 편의성을 최적하 하는데 중점을 두며, 이는 종종 암묵적인 설정을 통해 이루어진다.
이러한 암묵성은 작은규모에서는 훌륭하지만, 대규모에서는 예측불가능하고 신뢰할수 없는 Xcode의 행동을 초래하며 최적화를 어렵게 만든다.
Tuist는 이러한 문제를 해결하면서 복잡성과 비용을 적절한 수준으로 유지하는데 도움을 주는 대안이다.
Tust는 Xcode 프로젝트를 기본요소로 간주하여 향후 Xcode 업데이트에 대한 내성을 보장하며,
Xcode프로젝트 생성을 통해 팀에게 모듈화에 중점을둔 선언적 API를 제공한다.
Tuist는 프로젝트 선언을 사용하여 모듈화의 복잡서을ㅇ 단순화하고 다양한 환경에서 빌드나 테스트 같은 워크플로우를 최적화하며 Xcode프로젝트의 진화를 쉽게 만든다.
```

## 프로젝트 생성의 기초
```swift
Xcode 그 하위 빌드시스템, 그리고 Xcode의 프로젝트의 구조는 밀접하게 연결되어 있기때문에 유연성이 부족하다.
이 본질적인 설계는 개발자들에게 Apple에서 제공하는 문제를 해결할 수 있는 몇가지 방법만 남겨둔다.
하나의 해결책중 하나는 Cocoapods가 Ojbective-C 생태계에 종속서 관리를 도입하기 위해 처음 시작한 방법이다.
Tuist도 프로젝트 생성을 채택했으며 이는 Tuist의 주요 목표가 될 수 있다.
많은 개발팀이 팀 협업으로 인한 충돌문제를 완화하기 위해 프로젝트 생성을 사용하고 있따.
하지만 Tuist에게 프로젝트 생성은 최종 목표가 아니라 오히려 다음과 같은 광범위한 문제를 해결하기 위핸 기초 도구이다.

- 런타임 오류에 대한 걱정 없이 프로젝트의 모듈 구조를 수정하는 방법
- 종속성 그래프에 영향을 주지않고 타겟을 추가하거나 제거하는 방법
- 프로젝트 전체 크기와 관계 없이 작업을 분리하는 방법
- 프로젝트의 지속적인 건강과 무결성을 유지하여 개발자에게 좋은 환경을 제공하는 방법
```

## 어떻게 작동하는가?
```swift
Tuist를 시작하려면 Tuist의 도메인 특화 언어를 사용하여 프로젝트를 정의해야한다.
이는 Workspace.swift 또는 Project.swift와 같은 매니페스트 파일을 사용하는것을 의미한다.
Swift Package Manager를 사용해 본 경험이 있다면 접근 방식이 유사할것이다.
프로젝트를 정의한 후 Tuist는 다양한 워크플로우를 제공한다.

- 생성: Xcode와 호환되는 프로젝트를 생성한다.
- 빌드: Xcode프로젝트를 생성하고 xcodebuild를 사용하여 컴파일한다.
- 테스트: 빌드 워크플로우와 유사하게 Xcode프로젝트를 생성하고 xcodebuild를 사용하여 테스트한다.

추가적으로 Tuist는 타겟 중심의 프로젝트 생성 타겟 및 종속성을 바이너리로 교체, 다양한 환경에서 빌드 및 테스트 증분성을 보장하는 등의 최적화를 제공한다.
또한 팀이 정보에 기반한 결저을 내릴수 있도록 가이드를 제공한다.
```

## 다른 도구와의 비교
```swift
Swift Package Manager: SPM은 주로 종속성에 중점을 둔다. 반면 Tuist는 프로젝트 워크스페이스 타겟 스킴과 같은 개념을 사용하여 프로젝트를 정의한다.

XcodeGen: XcodeGen은 YAML 같은 직렬화 형식을 사용하여 프로젝틀르 정의한다.
그러나 이는 추가도구를 통합하지않으면 추상화나 체크를 구축하기 어렵게 만든다.

Baze: 원격캐싱기능으로 유명하나 Xcode 통합에느 많은 노력이 필요하다.
```

## 툴이 폐기되면 어떻게 되나?
```swift
문제가 발생하면 Xcode 프로젝트와 워크스페이스를 버전 관리 시스템에 추가하면 해결할 수 있다.
Tuist 핵심 설계 원칙중 하나는 Xcode 산업 표준에 가깝게 유지하는것이다
```

## 프로젝트를 gitignore에 추가해야하나?
```swift
선택은 자유다. .xcodeproj 및 .xcworkspace 파일을 .gitignoreㅔ 추가하면 많은 git 충돌을 피할수 있다.
처음에는 Tuist로 마이그레이션한뒤 모든게 원할하게 작동한다면 팀에게 tuist generate 명령어를 사용하도록 안내하고 익숙해지면 해당 파일들을 .gitignore에 추가해도 문제가 없다.
```

## 편리함의 비용
```swift
이제 잠시 시간을 내어 Xcode에서 편리함의 비용을 고려해보자.

소규모에서 대큐모 프로젝트까지 사용할 수 있는 코드 편집기를 설게하는것은 매우 어려운일이다.
많은도구들은 문제를 계층화하고 확장성을 제공함으로써 접근한다.
가장 아례의 계층은 매우 저수준이며 기본 빌드 시스템에 가깝고, 가장 우의 계층은 사용하기 편리하지만 유연성이 떨어지는 고수준 추상화이다.
이렇게하면 간단한 작업은 쉽게하고 나머지 작업도 가능하게 만든다.

그러나 애플은 Xcode에서 다른 접근방식을 택했다. 이유는 알수없지만 대규모 프로젝트의 도전과제를 최적화하는것이 그들의 목표가 아니었을 가능성이 크다.
그들은 소규모 프로젝트의 편리성에 과도하게 투자했고 유연성을 거의 제공하지 않으며 도구를 기본 빌드 시스템과 강하게 결합시켰다.
편리함을 달성하기 위해 쉽게 대체할수있는 합리적인 기본값을 제공하고 많은 암시적인 빌드타임 해결동작을 추가했으며, 이는 대규모에서 많은 문제 원인이 된다.
```

## 명시성과 규모
```swift
규모에 맞게 작업할때 명시성은 중요하다. 명시성은 빌드 시스템이 프로젝트 구조와 의존성을 미리 분석하고 이해하여 그렇지않으면 불가능한 최적화를 수행할수 있게 해준다.
동일한 명시성은 SwiftUI 프리뷰나, Swift 매크로와 같은 편집기 기능이 신뢰할 수 있고 예측 가능하게 작동하도록 보장하는데도 중요하다.
Xcode와 Xcode프로젝트는 편리함을 달성하기 위해 명시성을 받아들였으며, Swift Package Manager 역시 이 원칙을 이어받아 Xcode사용의 어려움이 Swift Package Manager에 나타나고 있따.
```

## Tuist의 역할
```swift
Tuist의 역할을 요약하면 암시적으로 정의된 프로젝트를 방지하고 명시석을 더 활용하여 더 나은 개발자 경험을 제공하는 도구로 볼수 있따.
Bazel 과 같은 도구는 이를 더 나아가 빌드 시스템 수준으로 가져간다.

이 문제는 커뮤니티에서 거의 논의되지 않지만 중요한 문제이다.
Tuist 작업을 하면서 많은 조직과 개발자가 현재 직면한 도전과제가 Swift 패키지 매니저로 해결될것이라고 생각하지만.
같은원칙을 기반으로 구축되었기때문에 유명한 Git 충돌을 완하하더라도 다른 영역에서 개발자 경험을 저하시키고 프로젝트를 최적하 할 수없게 만든다.

다음 섹션에서는 암시성이 개발자 경험과 프로젝트 건강에 어떠한 영향을 미치는지에 대한 실제 예를 살펴보자.
목록을 포괄적이지 않지만 Xcode 프로젝트나 스위프트 패키지 매니저 작업시 직면할수 있는 도전과제에 대한 좋은 아이디어를 제공할 것이다.
```

## 편리함이 방해가 되는 예
```swift
- 공유된 빌드 제품 디렉토리
Xcode는 각 제품에 대해 파생 데이터 디렉토리 내부의 디렉토리를 사용한다. 
그 안에 컴팡리된 바이너리, dSYM파일, 로그와 같은 빌드 아티팩트를 저장한다.
프로젝트의 모든 제품이 같은 디렉토리에 들어가고, 기본적으로 다른 대사에서 링크할 수 있도록 되어 있어, 대상들이 서로 암시적으로 의존하게될수 있다.
몇가지 대상만 있을때는 문제가 되지않지만, 프로젝트가 커질수록 디버그하기 어려운 빌드 실패로 나타날 수 있다.
이 설계 결정의 결과로 많은 프로젝트가 잘 정의되지 않은 그래프를 가지고 컴파일 하게된다.

- Tuist의 명시적 의존성 강제
Tuist는 암시적 의존성을 허용하지않도록 설정할 수 있는 생성 설정 옵션을 제공한다.
활성화 하면 대상이 명시적으로 선언되지 않은 의존성을 가져오려고 할때 빌드가 실패한다.

- 스킴에서 암시적 의존성 찾기
프로젝트가 커질수록 Xcode에서 의존성 그래프를 정의하고 유지하는것이 어려워진다.
이는 .pbxproj 파일에 빌드단계와 빌드 설정으로 코드화되어잇고, 그래프를 시각화하고 작업할수 있는 도구가 없기때문이다.
그래프의 변경(새 동적 프리컴파일된 프레임워크 추가)와 같은것들은 상위(번들에 프레임워크를 복사하는 새 빌드 단계 구축)에서 구성 변경을 요구할수 있다.
애플은 그래프 모델을 더 관리하기 쉽게 발전시키는 대신 빌드 타임에 암시적 의존성을 해결할 수 있는 옵션을 추가하는 것이 더 의미가 있다고 판단했다.
이는 다시 하번 의심스러운 설게 선택이다.
예를들어 파생데이터에 잇는 일부 상태로 인해 로컬에서는 빌드가 통과하지만 CI에서는 상태가 달라져서 컴파일이 실패할 수도 있다.

- SwiftUI 프리뷰 및 정적 라이브러리/ 프레임워크
SwiftUI 프리뷰나 Swift 매크로와 같은 편집기 기능은 편집중인 파일의 의존성 그래프 컴파일을 요구한다.
편집기와의 이 통합은 빌드 시스템이 모든 암시성을 해결하고 필요한 아티팩트를 출력해야하기 때문에.
그래프가 더 암시적일수록 빌드 시스템이 처리하기 어려워 진다.
이로 인해 많은 기능이 신뢰 할 수 없게 작동하는것이 놀랍지 않다.
개발자들이 SwiftUI 프리뷰 사용을 중단한 경우가많다. 대신 예제 앱을 사용하거나 정적 라이브러리나 스크립트 빌드단계를 피한다. 이러한것들이 기능을 깨뜨리기 때문이다.

- 병합 가능한 라이브러리
Dynamic 프레임워크는 더 유연하고 다루기 쉬운 반면 앱의 시작 시간은 느리게만든다.
반대로 Static 라이브러리는 시작시간이 빠르지만 컴파일 시간에 영향을 미치고 복잡한 그래프 시나리오에서는 다루기 어려운 면이 있다.
설정에 따라 동적 또는 정적 라이브러리를 선택할 수 있다면 좋을것이다.
애플도 이 점을 고려해 합칠 수 있는 라이브러리를 개발했다.
그러나 애플은 다시한번 빌드시간에 많은 추론 작업을 넘겼다.
종속성 그래프를 생각할때 타겟의 정적 또는 동적 특성 빌드 설정에따라 빌드시간이 결정된다고 상상해보자.
SwiftUI 미리보기가 깨지지않으면 안정적으로 동작하게 하는것은 어려운 일이다.

많은 사용자가 Tuist에 합칠 수 있는 라이브러리를 사용하고 싶다고 요청하지만, Tuist의 대답은 항상 같다.
필요하지않다. 타겟의 정적 또는 동적 특성을 생성시간에 제어하면 컴파일전에 그래프를 미리 알 수있다.빌드시간에 변수를 해결할 필요가 없다.
```

## 명시적
```swift

xcode로 개발을 확장하고자 하는 모든 개발자나 조직에게 추천하는 중요한 비공식 원칙이 있다.
바로 명시성을 받아들이라는것이다. 명시성이 순수한 Xcode 프로젝트로 관리하기 어렵다면.
Tuist나 Bazel을 고려해야한다.
그래야만 신뢰성, 예측가능성, 최적화가 가능해진다.

```
